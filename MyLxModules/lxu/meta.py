'''Autogenerated dummy meta module anabling code completion in Python editors
 MODO Build #621568
'''

class ChannelModifier:
    def __init__(self):
        self.m_eval = NoneType()

    def eval(self, data):
        '''
        '''
        pass

    def init_chan(self, desc):
        '''This is passed an AttributeDesc object which is used to init the
           channels.
        '''
        pass

    def post_alloc(self):
        '''
        '''
        pass



class ChannelUI:
    def item_enabled(self, item, message):
        '''
        '''
        pass

    def item_icon(self, item):
        '''
        '''
        pass



class Channels:
    def init_chan(self, desc):
        '''This is passed an AttributeDesc object which is used to init the
           channels.
        '''
        pass



class Command:
    def __init__(self):
        self._meta = NoneType()
        self._tmpmsg = NoneType()
        self._msg = NoneType()
        self._desc = NoneType()
        self._is_err = NoneType()
        self._e_flags = int()

    def button_name(self):
        '''Implement to return custom button or icon names.
        '''
        pass

    def cmd_add_notifier(self, name, args):
        '''Call to add a notifier for this command.
        '''
        pass

    def cmd_arg_custom(self, cust):
        '''Call during argument setup to customize the current argument.
        '''
        pass

    def cmd_args(self):
        '''Call to access arguments directly.
        '''
        pass

    def cmd_error(self, err, key):
        '''Call to raise an error with optional message key.
        '''
        pass

    def cmd_exec_flags(self):
        '''Call to get execution flags.
        '''
        pass

    def cmd_interaction_ok(self, err):
        '''Call to test if interaction is OK. If error is true the command fails.
        '''
        pass

    def cmd_message(self, key):
        '''Call to get the message for the command, or -- if the key is set
           -- set the message key.
        '''
        pass

    def cmd_read_args(self):
        '''Call to read all argument values.
        '''
        pass

    def cmd_read_args_isset(self):
        '''Call to read all argument 'isset' values.
        '''
        pass

    def cmd_set_arg(self, name, value):
        '''Call to set the value of an argument.
        '''
        pass

    def enabled(self):
        '''Implement to test if your command is enabled.
        '''
        pass

    def execute(self):
        '''Implement to execute your command.
        '''
        pass

    def icon_name(self):
        '''Implement to return custom button or icon names.
        '''
        pass

    def interact(self):
        '''Implement to do user interaction.
        '''
        pass

    def notifiers(self):
        '''Implement to add notifiers to your command.
        '''
        pass

    def preflight(self):
        '''Implement to test your command for execution before starting.
        '''
        pass

    def setup_args(self, desc):
        '''Implement to define command arguments.
        '''
        pass



class CustomArgument:
    def enabled(self, cmd):
        '''Implement to enable or disable the argument.
        '''
        pass

    def query(self, cmd):
        '''Implement to return a list of query results.
        '''
        pass

    def type(self, cmd):
        '''Implement to set the variable type.
        '''
        pass



class CustomChannelUI:
    def __init__(self):
        self.channel_name = NoneType()

    def enabled(self, item, read, msg):
        '''Implement this method to return false when the channel is disabled.
           The message can also be set.
        '''
        pass

    def hints(self, hints):
        '''Implement this method to set hints on the UIHints object. If this
           returns true then it overrides any other default hints.
        '''
        pass

    def uivalue(self):
        '''Implement this method to return a new UIValueHints object for
           the channel.
        '''
        pass



class Drop:
    def __init__(self):
        self._add = NoneType()
        self._cur = NoneType()
        self._icur = NoneType()

    def add_custom(self, name):
        pass

    def enabled(self, dest):
        '''Called multiple times during drag to determine if this drop server
           supports the destination under the mouse.
        '''
        pass

    def recognize_any(self, source):
        '''Called once on the start of drag/drop to detect if this drop server
           supports this source.
        '''
        pass

    def recognize_array(self, array):
        '''Called once on the start of drag/drop to detect if this drop server
           supports this array source.
        '''
        pass



class DropAction:
    def __init__(self):
        self._custom = NoneType()
        self._index = NoneType()
        self._name = NoneType()
        self._cust_num = NoneType()
        self._drop = NoneType()
        self._cust_base = NoneType()

    def enabled(self, dest):
        '''Tests if this action is enabled relative to this destination. Simple
           actions just return true or false; custom actions call add_custom().
        '''
        pass

    def exec_act(self):
        '''Implement to execute the action.
        '''
        pass

    def exec_custom(self, index):
        '''Implement to execute a custom action given by index.
        '''
        pass

    def name_msg(self, msg):
        '''Get the name for the action if it's different from the name in the
           message table. The string version is called first, and if that returns
           null then the message version is used.
        '''
        pass

    def name_str(self):
        '''Get the name for the action if it's different from the name in the
           message table. The string version is called first, and if that returns
           null then the message version is used.
        '''
        pass



class EvalModifier:
    def bind(self, item, ident):
        '''Implement this method to bind custom channels that aren't part of the
           channels metaclass. Call the next function to add them.
        '''
        pass

    def change_test(self):
        '''Any changes to custom channels will automatically trigger modifier
           invalidation. Implement this method to invalidate for other changes.
        '''
        pass

    def eval(self):
        '''Implement this method to evaluate inputs and write outputs.
        '''
        pass

    def include_item(self, item):
        '''Implement this method for modifiers that apply to all items. Return a
           list of indices, if nodes are to be created for this item.
        '''
        pass

    def mod_add_chan(self, item, chan, type):
        '''Call this method to add a named custom channel.
        '''
        pass

    def mod_attr(self):
        '''Call this method to get the Attributes object.
        '''
        pass

    def mod_cust_index(self, index):
        '''Call this method to get the attribute index of a custom channel.
        '''
        pass

    def mod_cust_value(self, index):
        '''Call this method to get the value of a custom channel.
        '''
        pass

    def mod_cust_write(self, index):
        '''Call this method to get the writable value of a custom channel.
        '''
        pass

    def mod_eval(self):
        '''Call this method to get the Evaluation object.
        '''
        pass

    def mod_index(self):
        '''Call this method to get the identifing index for this modifier node.
        '''
        pass

    def mod_item(self):
        '''Call this method to get the item for this modifier node.
        '''
        pass

    def mod_read_attr(self):
        '''Call this method to read channels defined in the Channels metaclass.
        '''
        pass

    def mod_result(self, res):
        '''Call this method to return a result other than e_OK.
        '''
        pass



class Falloff:
    def __init__(self):
        self._val = lxu.object.Value()
        self._invxfrm = lxu.object.Matrix()

    def bounded(self):
        '''Implement this method if the weight can be bounded.
        '''
        pass

    def bounds(self):
        '''Implement this to return the bounding box for the bounded region.
        '''
        pass

    def set_local(self, xfrm):
        '''Call this method to set the world transform for a local falloff.
        '''
        pass

    def valid(self):
        '''Implement this method if the weight can be non-zero anywhere.
        '''
        pass

    def weight_local(self, pos):
        '''Implement this to get the weight computed in local coordinates.
        '''
        pass

    def weight_world(self, pos):
        '''Implement this to get the weight computed in world coordinates.
        '''
        pass



class Meta:
    def __init__(self):
        self._type = NoneType()
        self._guid = NoneType()
        self._name = NoneType()
        self._parent = NoneType()
        self.types = lxu.meta.meta.Types()
        self._sub_list = list()

    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        '''Return the signature for this metaclass. Depends on type.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class MetaInterface:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        '''Return the signature for this metaclass. Depends on type.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class MetaObject:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        '''Return the signature for this metaclass. Depends on type.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def extract(self, com):
        '''Get the implementation class object from the COM object.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def spawn(self):
        '''Allocate a new instance of the COM object.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class MetaRoot:
    def __init__(self):
        self._type = str()
        self._done = bool()
        self._guid = NoneType()
        self._name = NoneType()
        self._parent = NoneType()
        self._dbg = NoneType()
        self.types = lxu.meta.meta.Types()
        self._sub_list = list()

    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        '''Return the signature for this metaclass. Depends on type.
        '''
        pass

    def debug(self, text):
        '''Debuging can be enabled to see the tree in the event log.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def initialize(self):
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class MetaServer:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''Return the signature for this metaclass. Depends on type.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_ChannelModifier:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_channelui(self, cls):
        '''Add a ChannelIU class
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''Internal method
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Internal method
        '''
        pass

    def set_supertype(self, typename):
        '''Set the supertype for this package, making it an item type. If the
           typename is omitted then this is a root type.
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_Channels:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_Command:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_notifier(self, name, args):
        '''Notifiers that don't vary with arguments can be added here.
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''Internal metaclass method.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_type_UI(self):
        pass

    def set_type_flags(self, flags):
        pass

    def set_type_model(self):
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_Drop:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_action(self, name, action, custom):
        '''Actions are added one at a time. The name is the key used for the
           default action name in the message table. Custom drop actions can
           add their own actions, but are not mappable.
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''(internal) We set the index of each action and build
           the tag string that identifies non-custom actions
        '''
        pass

    def alloc_inst(self):
        '''(internal) Allocate the instance and set actions to use it.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_source_type(self, type):
        '''
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_EvalModifier:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_dependent_graph(self, graphname):
        '''Modifiers can be automatically invalidated for changes related to
	   named graphs.
        '''
        pass

    def add_dependent_type(self, typename):
        '''Modifiers can be automatically invalidated for changes related to
	   other item types.
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''Internal metaclass method.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_all_items(self):
        '''A modifier associated with an item type will allocate one modifier
	   node for each item of that type. Calling get_all_items() will instead
           configure the modifier to process all items, adding zero or more
           nodes for each.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def invalidate(self, scene, reset):
        '''Any change (other than item types or graphs) that require the modifier
	   nodes to be refreshed should invalidate the modifier. If 'reset' is
	   true then the results of all modifier nodes are cleared regardless.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_itemtype(self, typename):
        '''If there's a package server in the meta tree then that's automatically
           set as the main item type for the modifier. That can be overridden
           with this call.
        '''
        pass

    def set_simulation(self):
        '''Call to set the modifier to be a simulation.
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_Falloff:
    def __init__(self):
        self._type = str()
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        '''Internal metaclass method.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def extract(self, com):
        '''Get the implementation class object from the COM object.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_local(self, local):
        '''Set the falloff to operate in local coordinates.
        '''
        pass

    def spawn(self):
        '''Allocate a new instance of the COM object.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_ObjectEvaluation:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_Package:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_channelui(self, cls):
        '''Add a ChannelIU class
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''Internal method
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Internal method
        '''
        pass

    def set_supertype(self, typename):
        '''Set the supertype for this package, making it an item type. If the
           typename is omitted then this is a root type.
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_SchematicConnection:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        '''Internal metaclass method.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def invalidate(self):
        '''Invalidate the dynamic state of item connections.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_dynamic(self):
        '''Set the connections to be tested for each individual item.
        '''
        pass

    def set_graph(self, name, reverse, manual):
        '''Set the graph name for normal, graph-based connections. The graph can
           be set to be reversed. 'manual' can be True to use the computed list
           for the contents of the links.
        '''
        pass

    def set_itemtype(self, name, multiple, ordered):
        '''Set an item type to limit connections to exactly items matching this type.
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_SelectionType:
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def add_tag(self, key, value):
        pass

    def alloc(self):
        ''' (internal) Return implementation class.
        '''
        pass

    def clear(self):
        '''Set the current selection to empty.
        '''
        pass

    def deselect(self, id):
        '''Deselect this id.
        '''
        pass

    def drop(self):
        '''Clear the selection and make this selection type topmost.
        '''
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ID4(self):
        '''Get the type code for the selection.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def id_from_pkt(self, pkt):
        '''Get an id from a selection packet. This dereferences the packet
           pointer and returns the int inside.
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pkt_from_id(self, id):
        '''Get a packet from a numeric id code. The packet is effectively a
           pointer to the int, and is valid until this is called again.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def remove(self, id):
        '''Remove this id from the selection anywhere it might occur.
        '''
        pass

    def select(self, id, add):
        '''Add this id to the selection, or if 'add' is false, set the selection
           to only this id.
        '''
        pass

    def set_undoable(self, supportUndo):
        '''Set the selection to be undoable. Default is non-undoable.
        '''
        pass

    def set_username(self, base, key):
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class Meta_ViewItem3D:
    def __init__(self):
        self._type = str()
    def add(self, sub):
        '''Add another meta object as a child of this one.
        '''
        pass

    def alloc(self):
        pass

    def dump(self, prefix):
        '''Output the contents of the meta node tree with indenting.
        '''
        pass

    def enable_background(self):
        '''Enable background drawing.
        '''
        pass

    def enable_test(self):
        '''Enable alternate testing.
        '''
        pass

    def find_any(self, type, guid, miss):
        '''Find a node with matching type/guid, searching first inside this node
           but searching higher up the tree until somthing matches.
        '''
        pass

    def find_sub(self, type, guid):
        '''Find first node with a matching type/guid under this node.
        '''
        pass

    def flatten(self):
        '''Return this meta and all sub-metas in a list.
        '''
        pass

    def get_ifcs(self, guid):
        '''Get the list of interfaces matching the given guid under this node.
           The list is returned as tuples: ((class, meta), ...)
        '''
        pass

    def init_ifcs(self, guid):
        '''Initialize the _sub_ifcs attribute as a list of interfaces. If no
           guid is given we use the metaclass guid itself.
        '''
        pass

    def pre_init(self):
        '''Do any self-modification or other steps before initialization. Return
           true as long as there is more to do.
        '''
        pass

    def set_world_space(self, world):
        '''Set the package to draw in world space. Normally locators are drawn in
           their local coordinate space.
        '''
        pass

    def test(self, type, guid):
        '''Test this meta node against a type and guid and return true for match.
           All testing allows for type or guid to be None for wildcard.
        '''
        pass



class ObjectEvaluation:
    def alloc_obj(self, mod):
        '''Implement this method to allocate and return a new object.
        '''
        pass

    def init_obj(self, mod, obj):
        '''Implement this method to initialize an object alloced by metaclass.
        '''
        pass



class Package:
    def __init__(self):
        self.m_item = NoneType()

    def add(self):
        '''Item added to scene -- either on create or on delete undo.
        '''
        pass

    def after_load(self):
        '''Item finished loading.
        '''
        pass

    def doomed(self):
        '''Item final destroy.
        '''
        pass

    def initialize(self, super):
        '''Initial package creation.
        '''
        pass

    def loading(self):
        '''Item create on load.
        '''
        pass

    def newborn(self, item, flags):
        '''Item initial creation.
        '''
        pass

    def parent_ok(self, parent):
        '''Return true if the parent is valid.
        '''
        pass

    def remove(self):
        '''Item removed from scene -- either on delete or on create undo.
        '''
        pass

    def synth_name(self):
        '''Return a synthetic name for the item when it has no other name.
        '''
        pass



class SchematicConnection:
    def __init__(self):
        self._tmpflag = int()

    def allow(self, ifrom, ito):
        '''Return true if a link between these items is legal.
        '''
        pass

    def connect(self, ifrom, ito, toIndex):
        '''Make a connection between two items. This is only called if no graph
           is specified.
        '''
        pass

    def disconnect(self, ifrom, ito):
        '''Break a connection between two items. This is only called if no graph
           is specified.
        '''
        pass

    def get_list(self, item):
        '''Get the list of items with incoming connections. This is only called
           if no graph is specified, or if the graph is manual.
        '''
        pass

    def set_multiple(self, ordered):
        pass

    def set_single(self):
        pass

    def test_item(self, item):
        '''Test if an item should have a connection point. If it should then
           call set_single() for a single connection, or set_multiple() for
           multiple (perhaps ordered) connections.
        '''
        pass



class SelectionType:
    def subtype(self, id):
        '''Implement to return a subtype code for a given selected ID.
        '''
        pass



class Simulation:
    def cleanup_sim(self):
        pass

    def enabled(self, chanRead):
        pass

    def init_sim(self, time, sample):
        pass

    def step(self, dt):
        pass

    def step_size(self):
        pass



class ViewItem3D:
    def __init__(self):
        self.m_item = NoneType()

    def draw(self, chanread, stroke, flags, color):
        '''This method is called to draw the package in 3D, reading channels from
           the read object and drawing with the stroke object.
        '''
        pass

    def drawbg(self, chanread, stroke, color):
        '''Background drawing can also be optionally done. This method has to be
           enabled with enable_background().
        '''
        pass

    def drawtest(self, chanread, stroke, flags, color):
        '''Hit testing can be done by drawing a different stroke pattern. This
           method has to be enabled with enable_test()
        '''
        pass



def InitAll():
    '''This is called to init all root metaclasses. Called from lxserv after
       importing all lxserv modules.
    '''
    pass

